import{Request as e,Response as f,Deref as z,Authenticate as g,Resolve as h,Message as i,Reject as j}from"./message.js";import{any as d,extern as b,type as A,struct as c,utf16 as a,reference as B,array as C}from"../rob/encodings.js";import{ExternScheme as k}from"../rob/scheme-handler.js";import{ExternHandler as D,COMMUNICATION_SCHEMES as E}from"../rob/extern-handler.js";import{Read as F,Write as G}from"../rob/reader-writer.js";import{bufferString as H,randomInt as I}from"../utils/mod.js";import"../rob/built-ins.js";import{_Array as l,_Error as m,_Module as n,_Null as o,_Number as p,_Object as q,_String as r,_Undefined as s}from"../rob/built-ins.js";import{Always as J,Never as K}from"./authenticator.js";import*as L from"./authenticator.js";import{handler as M,SMBuilder as t,_defined as u,_get as v,_getBind as w}from"./stack-machine-generator.js";import{C as x,StackMachine as y}from"./stack-machine.js";export const moduleURL=import.meta.url;export class LinkError extends Error{static moduleURL=moduleURL;static encoding=c(this,{message:a,stack:a,errors:d})}export class EncodingError extends LinkError{static moduleURL=moduleURL;static encoding=c(this,{message:a,stack:a,errors:d})}export class AuthenticationError extends LinkError{static moduleURL=moduleURL;static encoding=c(this,{message:a,stack:a})}let DEBUG=["message","buffer"];export class Linkable{constructor(a){if("function"==typeof a)return this.apply=(b,c,d)=>a.apply(b,c,d),this;Object.assign(this,a)}static moduleURL=moduleURL;static encoding=b("link")}export class LinkedReference{static moduleURL=moduleURL;static encoding=b("link")}export class Linked extends t{static moduleURL=moduleURL;static encoding=b("link");constructor(a,b){return super(),this.connection=a,this.sub(b)}async onThen(){return this.connection.request(new h(this.stack))}}export class LinkScheme extends k{constructor(a){super(),this.connection=a,this.itemCache=new Map,this.uriCache=new WeakMap,this.remoteCache=new Map,this.registry=new FinalizationRegistry(a=>{this.connection.send(new z(a))})}getURI(a){if(a.constructor===Linked||this.uriCache.has(a))return this.uriCache.get(a);let b=`link:${I().toString(32)}`;return this.itemCache.set(b,a),this.uriCache.set(a,b),b}getItem(a){if(this.itemCache.has(a))return this.itemCache.get(a);if(this.remoteCache.has(a))return this.remoteCache.get(a).deref();let b=new LinkedReference;return this.registry.register(b,a),this.uriCache.set(b,a),this.remoteCache.set(a,new WeakRef(b)),new Linked(this.connection,b)}clear(a){this.itemCache.delete(a),0===this.itemCache.size&&(this.connection.connectionInterface.close(),console.log(`closed connection ${connection.id} due to cache size of null`))}}let MESSAGING_HEAD=[r,p,q,m,o,s,l,n,i,g,e,f,h,j,Linked,LinkedReference,Linkable,y,x,v,w,u],LINK_API=new Linkable({import:async function(a){return import(a)},ping:async function(a){return a}});export class WSLink{constructor({path:a="/",authenticator:b=new J}={},c=LINK_API){this.path=a,this.authenticator=b,this.api=c}route(a){return"GET"===a.method&&"websocket"===a.headers.get("upgrade")&&new URL(a.url).pathname===this.path}async onRequest(a,b){let{socket:d,response:e}=Deno.upgradeWebSocket(a);try{new Connection(d,this.api,this.authenticator,void 0,a.headers),b(e)}catch(c){console.log(c),b(new f(c.toString(),{status:400}))}}}export class Connection{constructor(a,b={},c=new J,d=new Linkable(L),e){this.authenticator=c,this.authenticated=!1,this.connectionInterface=a,this.api=b,this.authApi=d,this.initialRequestHeaders=e,this.connectionInterface.onmessage=a=>this.recieve(a.data),this.secureResolvables=!1,this.closers=[],this.connectionInterface.onclose=b=>{for(let a of this.closers)a()},this.unresolvedPromises=new Map,this.instances=new Map,this.externHandler=new D({...E,link:new LinkScheme(this)})}authenticate(a=""){return this.request(new g(a,this.authApi))}async send(b){try{let c=new G(this.externHandler,MESSAGING_HEAD);DEBUG.includes("message")&&console.log("<<< ",b);try{d(c)(b)}catch(f){throw new EncodingError("unable to encode message.  encodings probably not defined")}let a=c.toBuffer();DEBUG.includes("buffer")&&console.log(`<${a.byteLength.toString().padStart(4,"0")}< ${H(a)}`),this.connectionInterface.send(a)}catch(e){if(e instanceof EncodingError)throw e;throw new LinkError("error sending data over link")}}async recieve(c){let b=c;c instanceof Blob&&(b=await c.arrayBuffer());let e=new F(this.externHandler,b,MESSAGING_HEAD),a;try{a=await d(e)()}catch(m){throw new EncodingError("unable to decode message")}if(DEBUG.includes("buffer")&&console.log(`>${b.byteLength.toString().padStart(4,"0")}> ${H(b)}`),DEBUG.includes("message")&&console.log(">>>",a),a instanceof f){this.unresolvedPromises.get(a.id).resolve(a.value),this.unresolvedPromises.delete(a.id);return}if(a instanceof j){this.unresolvedPromises.get(a.id).reject(a.value),this.unresolvedPromises.delete(a.id);return}if(a instanceof z&&this.externHandler.clear(a.uri),a instanceof h){try{if(!this.authenticated|this.secureResolvables&&!(a.resolver instanceof y))throw new AuthenticationError("request breaks connection security policy");let i=await a.resolver.resolve();await this.send(a.response(i))}catch(k){console.log("caughet err"),this.send(a.error(k))}return}if(a instanceof g){try{if(await this.authenticator.authencicate(a.key,a.api,this.initialRequestHeaders))this.authenticated=!0,await this.send(a.response(this.api));else throw new AuthenticationError("could not authenticate")}catch(l){this.send(a.error(l)),this.connectionInterface.close()}return}}async request(a){if(!(a instanceof e))throw new Error("requests only work with Request Messages");let b=new Promise((b,c)=>this.unresolvedPromises.set(a.id,{resolve:b,reject:c}));return await this.send(a),b}addCloser(a){this.closers.push(a)}}let activeConnections=new Map;export async function link(a,d="",e={},f=new K){if("localhost"===new URL(a).hostname){let b=new URL(a);b.hostname="127.0.0.1",a=b.toString()}if(activeConnections.has(activeConnections))return link.connections[a];{let g=new WebSocket(a);await new Promise((a,b)=>{g.onopen=()=>a(g),g.onerror=()=>b(g),g.onclose=a=>{onclose(a),b(g)}});let c=new Connection(g,e,f),h=await c.authenticate(d);return activeConnections.set(a,c),h}}export async function linkFile(a,b){b||(b=defaultUrl());//!! relative path resolution may not work on safari
let c;if(/^\.?\.?\//.test(a)){let d=new Error().stack.split("\n").filter(a=>/https?:\/\//g.test(a)),e=d[1].slice(d[1].lastIndexOf("http"),d[1].lastIndexOf(".")+3);c=new URL(a,e).toString()}else c=a;let f=await link(b);return f.import(c)}export function unlink(a){a||(a=defaultUrl());let b=new URL(a);"localhost"===b.hostname&&(b.hostname="127.0.0.1");let c=activeConnections.get(b.toString());c&&c.connectionInterface.close()}function defaultUrl(){let a=new URL(location?.origin??import.meta.url);if("http:"===a.protocol)a.protocol="ws:";else if("https:"===a.protocol)a.protocol="wss:";else throw new Error("cannot auto define socket URL");return a.origin.toString()}export function connection(a){return M(a).connection}